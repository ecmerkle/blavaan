<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ordinal Models and Version 0.4 Updates • blavaan</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Ordinal Models and Version 0.4 Updates">
<meta property="og:description" content="blavaan">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">blavaan</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.3-18.853</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Examples
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/converge.html">Estimation and Convergence</a>
    </li>
    <li>
      <a href="../articles/prior.html">Prior Distributions</a>
    </li>
    <li>
      <a href="../articles/invariance.html">Measurement Invariance</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../articles/resources.html">Resources</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/ecmerkle/blavaan">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="https://groups.google.com/d/forum/blavaan">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="ordinal_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Ordinal Models and Version 0.4 Updates</h1>
                        <h4 class="author">Ed Merkle</h4>
            
      
      
      <div class="hidden name"><code>ordinal.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level3">
<h3 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h3>
<p>Structural equation models with ordinal observed variables are supported starting in <em>blavaan</em> 0.4-1 (<code>target="stan"</code> only). This document describes the overall approach, which includes model estimation, threshold parameters, log-likelihood calculation, posterior predictive p-values, and Jacobians. We assume that you are somewhat familiar with the layout of SEM; if not, some technical detail and examples are found in <span class="citation">Merkle and Rosseel (2018)</span> and, more recently, <span class="citation">Merkle et al. (n.d.)</span> (links to these papers are in the references section). We aim here to provide enough detail to elucidate the new blavaan features, while being informal enough for you to not get (too) bored.</p>
</div>
<div id="estimation" class="section level3">
<h3 class="hasAnchor">
<a href="#estimation" class="anchor"></a>Estimation</h3>
<p>Ordinal observed variables are handled via data augmentation, in the style of <span class="citation">Chib and Greenberg (1998)</span>. You might already know this, but the phrase <em>data augmentation</em> is imprecise in the context of SEM. This is because there are many possible things that could be augmented, each of which can make model estimation easier. We could be augmenting observed data with predictions of missing values, which is related to multiple imputation methods. We could be augmenting the observed data with the latent variables, which can simplify likelihood calculation (leading to what is sometimes called a <em>conditional</em> likelihood, though <em>conditional</em> also has many meanings). Or we could be augmenting categorical observed variables with underlying, latent continuous variables. This last type of augmentation is what we are doing here. In our testing, we found it to be faster and more efficient than other approaches that would sample latent variables alongside other model parameters (the latent variables are integrated out of our likelihoods here; similar to the description from <span class="citation">Merkle et al. (n.d.)</span>).</p>
<p>In our data augmentation implementation, each ordinal observation (e.g., <span class="math inline">\(y\)</span>) is used to generate a continuous, underlying counterpart (e.g., <span class="math inline">\(y^\ast\)</span>). This <span class="math inline">\(y^\ast\)</span> must obey the model’s threshold parameters (commonly denoted <span class="math inline">\(\mathbf{\tau}\)</span>), based on the value of the observed data. For example, ignoring subscripts on <span class="math inline">\(y^\ast\)</span> and assuming an ordinal variable with 4 categories, we would have <span class="math display">\[\begin{align*}
y^* &lt; \tau_1 &amp;\text{ if }y = 1 \\
\tau_1 &lt;\ y^* &lt; \tau_2 &amp;\text{ if }y = 2 \\
\tau_2 &lt;\ y^* &lt; \tau_3 &amp;\text{ if }y = 3 \\
y^* &gt;\ \tau_3 &amp;\text{ if }y = 4
\end{align*}\]</span> where we require <span class="math inline">\(\tau_1 &lt; \tau_2 &lt; \tau_3\)</span>. We generate such a <span class="math inline">\(y^*\)</span> separately for each ordinal observation in the dataset. These all become additional, bounded parameters in the Stan file.</p>
<p>The Stan User’s Guide has a helpful example of multivariate probit regression using a related approach; see <a href="https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html" class="uri">https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html</a>. The trickiest parts involve enforcing the boundaries of the <span class="math inline">\(y^*\)</span> variables, and ensuring that the threshold parameters for each ordinal variable are ordered correctly (while allowing for the possibility that different ordinal variables have different numbers of thresholds). These require some Jacobian adjustments that took a good deal of time to code correctly (some further detail appears in a later section).</p>
<p>Once the above parameters are defined and generated, the remainder of the model estimation is similar to the simpler situation where all observed variables are continuous. In terms of the Stan file, most of the ordinal overhead comes in the transformed parameters block. Once we get to the model block, most things operate as they would with continuous data.</p>
</div>
<div id="thresholds-priors" class="section level3">
<h3 class="hasAnchor">
<a href="#thresholds-priors" class="anchor"></a>Thresholds &amp; Priors</h3>
<p>The prior distributions on the threshold (<span class="math inline">\(\tau\)</span>) parameters are more involved than they may appear. This is because, as described in the previous section, the threshold parameters for a single variable must be ordered. So if we say, for example, that all thresholds have a normal(0,1) prior distribution, we are ignoring the fact that one threshold’s value influences the size of other thresholds’ values. As Michael Betancourt describes on Stan Discourse, such a prior “interacts with the (ordering) constraint to enforce a sort of uniform repulsion between the interior points, resulting in very rigid differences.”</p>
<p>quote from <a href="https://discourse.mc-stan.org/t/prior-choice-for-ordered-inverse-transformed-parameters/16378/3" class="uri">https://discourse.mc-stan.org/t/prior-choice-for-ordered-inverse-transformed-parameters/16378/3</a></p>
<p>To address this issue, we first define an unconstrained, unordered parameter vector whose length equal the number of thresholds in the model. Call this vector <span class="math inline">\(\mathbf{\tau}^*\)</span>. We then obtain ordered thresholds by exponentiating the unordered parameter vector in a specific manner. The manner in which this works is exactly the same as how Stan defines a parameter of type <code>ordered</code>. See <a href="https://mc-stan.org/docs/2_27/reference-manual/ordered-vector.html" class="uri">https://mc-stan.org/docs/2_27/reference-manual/ordered-vector.html</a>.</p>
<p>The idea is most easily shown via example. Say that we have an ordinal variable with 4 categories. Then the three thresholds for this variable are obtained via: <span class="math display">\[\begin{align*}
\tau_1 &amp;= \tau^*_1 \\
\tau_2 &amp;= \tau^*_1 + \exp(\tau^*_2) \\
\tau_3 &amp;= \tau^*_1 + \exp(\tau^*_2) + \exp(\tau^*_3).
\end{align*}\]</span> We then place normal prior distributions on the unordered <span class="math inline">\(\tau^*\)</span> parameters, as opposed to placing priors on the ordered <span class="math inline">\(\tau\)</span> parameters. These normal priors imply that the lowest threshold (<span class="math inline">\(\tau_1\)</span> above) has a normal prior, while differences between successive <span class="math inline">\(\tau\)</span>’s have log-normal priors. In blavaan, these priors can be specified in the usual two ways. First, we could add the <code>dp</code> argument to a model estimation command as follows.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">dp</span> <span class="op">=</span> <span class="fu"><a href="../reference/dpriors.html">dpriors</a></span><span class="op">(</span>tau <span class="op">=</span> <span class="st">"normal(0, .5)"</span><span class="op">)</span></code></pre></div>
<p>which would assign this prior to all the unordered <span class="math inline">\(\tau^*\)</span> parameters in the model. Second, we could specify priors for specific threshold parameters in the model specification syntax. For example, say that we have a 4-category observed variable called <code>x1</code>. Then unique priors for each the three thresholds could be specified in the model syntax via</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">x1</span> <span class="op">|</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(-1, 1)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t1</span> <span class="op">+</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(0, .5)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t2</span> <span class="op">+</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(0, 1)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t3</span></code></pre></div>
<p>It is not clear at this time that priors on the <span class="math inline">\(\tau^*\)</span> parameters are the best option. In a 2019 paper, Michael Betancourt describes a Dirichlet prior that regularizes the thresholds of an ordinal regression model. Such a strategy would seem to work for SEM, and it could be especially useful for datasets where some categories of the ordinal variable are sparse. These issues warrant further study.</p>
<p><a href="https://betanalpha.github.io/assets/case_studies/ordinal_regression.html" class="uri">https://betanalpha.github.io/assets/case_studies/ordinal_regression.html</a></p>
</div>
<div id="likelihood-computations" class="section level3">
<h3 class="hasAnchor">
<a href="#likelihood-computations" class="anchor"></a>Likelihood Computations</h3>
<p>Once we get to continuous data in the model block, it seems reasonable to expect simple likelihood computations. But it depends on what likelihood you want to compute. The likelihood used for sampling in Stan is a simple multivariate normal of the <span class="math inline">\(y^*\)</span> observations, combined with any continuous observed variables in the model. This is indeed simple to compute. But it is not the likelihood you want to use for model comparison. For one thing, all the <span class="math inline">\(y^*\)</span> parameters associated with ordinal data are involved in this likelihood, so quantities like the effective number of parameters become very inflated. The number of parameters involved in this likelihood also increases with sample size, which is generally bad in the land of model comparison metrics. See <span class="citation">Merkle, Furr, and Rabe-Hesketh (2019)</span> for more detail here.</p>
<p>All this means that, for quantities like WAIC and PSIS-LOO, we must compute a second model likelihood that involves the observed, ordinal <span class="math inline">\(y\)</span> variables and that integrates over the latent <span class="math inline">\(y^*\)</span> variables. This is a difficult problem that amounts to evaluating the CDF of a sometimes-high-dimensional, multivariate normal distribution <span class="citation">(see Chib and Greenberg 1998, Equation 11)</span>. We follow <span class="citation">Chib and Greenberg (1998)</span> in approximating these integrals via Monte Carlo simulation, relying on the <em>tmvnsim</em> package <span class="citation">(Bhattacjarjee 2016)</span>. For each case, we generate many random samples from the appropriate truncated multivariate normal and average over the resulting importance sampling weights. The procedure is computationally intensive and also time intensive, so we have to balance the number of random samples drawn with the amount of time that it takes. The number of samples currently defaults to 20 times the number of ordinal variables, with a maximum of 200. Users can also set the number of samples to draw at the time of model estimation, by setting <code>llnsamp</code> within the <code>mcmcextra$data</code> argument. For example, to draw 100 samples for the approximation, an argument to <code><a href="../reference/bsem.html">bsem()</a></code> or similar functions would be</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mcmcextra</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>llnsamp <span class="op">=</span> <span class="fl">100</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>This is not the only way that we could compute the marginal likelihood. The gold standard would probably be a quadrature method that integrates over the latent variables, as opposed to a method that integrates over the <span class="math inline">\(y^*\)</span> variables. Quadrature over the latent variables would also reduce the dimension of integration for most models, so we may switch to this method in the future.</p>
<p>There also exists a relatively new method by CITE for evaluating the CDF of the multivariate normal, with an implementation of the method appearing in the package <em>TruncatedNormal</em> CITE. In our limited testing, the <em>TruncatedNormal</em> implementation was considerably slower than <em>tmvnsim</em> for our purposes. But we may revisit this issue in the future.</p>
<p>TODO Bayes factor, use chib’s identity?</p>
</div>
<div id="posterior-predictive-p-values" class="section level3">
<h3 class="hasAnchor">
<a href="#posterior-predictive-p-values" class="anchor"></a>Posterior Predictive p-values</h3>
<p>Posterior predictive p-value (ppp) computations also receive a speed boost in the 0.4 series. These computations now occur in Stan, whereas they previously occurred in R after model estimation. As discussed by CITE_mplus, the ppp computations needed for models with missing data can be excessively slow, requiring us to run an EM algorithm for each posterior sample in order to find the “H1” (“saturated”) model covariance matrix. The solution by CITE_mplus is to realize that we do not need to use a fully-optimized H1 covariance matrix in order to compute the ppp. In <em>blavaan</em>, we consequently run an EM algorithm for a fixed number of iterations in order to compute an H1 covariance matrix that is “good enough” for the ppp. The default number of iterations it set to 20, and users can change the default by supplying an <code>emiter</code> value via the <code>mcmcextra</code> argument. For example,</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mcmcextra</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>emiter <span class="op">=</span> <span class="fl">50</span><span class="op">)</span><span class="op">)</span></code></pre></div>
</div>
<div id="jacobians" class="section level3">
<h3 class="hasAnchor">
<a href="#jacobians" class="anchor"></a>Jacobians</h3>
<p><em>(This section is likely only relevant to you if you are editing/writing Stan models.)</em> The Stan model underlying <em>blavaan</em> currently requires Jacobian adjustments in two places. This section briefly reviews the ideas underneath the adjustments, which my future self may wish to remember.</p>
<p>We need a Jacobian adjustment when we place a prior on something that does not appear in the Stan <code>parameters</code> block. The Jacobian tells us about the implied priors of the things in the <code>parameters</code> block, based on the priors that appear in the <code>model</code> block.</p>
<p>The Jacobian comes from the statistics literature on “change of variables”: we are applying a function to some random variables, and finding the distribution of the function based on the original distribution of the random variables. When it comes to Stan models, this means we are starting with the priors from the <code>model</code> block and finding the implied priors for the <code>parameters</code> block. This confused me for a long time because, in the Stan file, the functions naturally go in the opposite direction: starting with the <code>parameters</code> block, and moving to the <code>model</code> block.</p>
<p>The fact that our functions go from <code>model</code> to <code>parameters</code> is convenient, though, because Jacobian adjustments require the inverse functions. And the inverse functions move us from <code>parameters</code> to <code>model</code>, so they already exist in the Stan model. We just need to find the appropriate derivatives of these functions, which lead to the Jacobian.</p>
<p>As an example, consider the fact that <em>blavaan</em> allows users to choose whether priors go on standard deviation, variance, or precision parameters. The standard deviations appear in the <code>parameters</code> block regardless of what the user chooses (the Stan model is precompiled at the time of package installation). Say that the user wants priors on precisions. We transform the standard deviations to precisions in the <code>model</code> block, then put the prior on the precision. In addition to this prior, we need the Jacobian of the function that starts with a standard deviation (call it <span class="math inline">\(\sigma\)</span>) and transforms to precision (<span class="math inline">\(\sigma^{-2}\)</span>). The derivative of <span class="math inline">\(\sigma^{-2}\)</span> with respect to <span class="math inline">\(\sigma\)</span> is <span class="math inline">\(-2 \sigma^{-3}\)</span>. And because this is a simple function mapping a single parameter to a different value, the Jacobian is the absolute value of this derivative, which is <span class="math inline">\(2 \sigma^{-3}\)</span>. In the Stan file, we would then add the log of this Jacobian to <code>target</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>target += log(<span class="dv">2</span>) - <span class="dv">3</span>*log(sigma)</span></code></pre></div>
<p>Further examples and discussion can be found in:</p>
<p><a href="https://mc-stan.org/users/documentation/case-studies/mle-params.html" class="uri">https://mc-stan.org/users/documentation/case-studies/mle-params.html</a></p>
</div>
<div id="summary" class="section level3">
<h3 class="hasAnchor">
<a href="#summary" class="anchor"></a>Summary</h3>
<p>The <em>blavaan</em> 0.4 series offers enhanced functionality in a variety of areas. The computational decisions that we have made reflect a balance between estimation precision and estimation speed. It will be the case that the software defaults behave poorly in some situations. For example, the default prior distributions can be problematic in certain situations, the likelihood approximations for ordinal models may not be as precise as desired, and the new ppp computations may behave differently than previous computations. We encourage users to carry out sensitivity analyses, and also to report bugs!</p>
</div>
<div id="references" class="section level3 unnumbered">
<h3 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h3>
<div id="refs" class="references">
<div id="ref-tmvnsim">
<p>Bhattacjarjee, Samsiddhi. 2016. <em>tmvnsim: Truncated Multivariate Normal Simulation</em>. <a href="https://CRAN.R-project.org/package=tmvnsim">https://CRAN.R-project.org/package=tmvnsim</a>.</p>
</div>
<div id="ref-chigre98">
<p>Chib, S., and E. Greenberg. 1998. “Analysis of Multivariate Probit Models.” <em>Biometrika</em> 85: 347–61.</p>
</div>
<div id="ref-merfit21">
<p>Merkle, E. C., E. Fitzsimmons, J. Uanhoro, and B. Goodrich. n.d. “Efficient Bayesian Structural Equation Modeling in Stan.” <em>Journal of Statistical Software</em>. <a href="https://arxiv.org/abs/2008.07733">https://arxiv.org/abs/2008.07733</a>.</p>
</div>
<div id="ref-merfur19">
<p>Merkle, E. C., D. Furr, and S. Rabe-Hesketh. 2019. “Bayesian Comparison of Latent Variable Models: Conditional Versus Marginal Likelihoods.” <em>Psychometrika</em> 84: 802–29. <a href="https://arxiv.org/abs/1802.04452">https://arxiv.org/abs/1802.04452</a>.</p>
</div>
<div id="ref-merros18">
<p>Merkle, E. C., and Y. Rosseel. 2018. “blavaan: Bayesian Structural Equation Models via Parameter Expansion.” <em>Journal of Statistical Software</em> 85 (4): 1–30. <a href="https://www.jstatsoft.org/article/view/v085i04">https://www.jstatsoft.org/article/view/v085i04</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Edgar Merkle, Yves Rosseel, Ben Goodrich.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
