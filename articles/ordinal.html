<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Ordinal Models in blavaan ‚Ä¢ blavaan</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Ordinal Models in blavaan">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">blavaan</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5-5.1296</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-basics" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Basics</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-basics">
<li><a class="dropdown-item" href="../articles/start.html">Getting Started</a></li>
    <li><a class="dropdown-item" href="../articles/prior.html">Prior Specification</a></li>
    <li><a class="dropdown-item" href="../articles/estimate.html">Estimation</a></li>
    <li><a class="dropdown-item" href="../articles/convergence_efficiency.html">Convergence and Efficiency Evaluation</a></li>
    <li><a class="dropdown-item" href="../articles/summaries.html">Model Summaries</a></li>
    <li><a class="dropdown-item" href="../articles/plotting.html">Plots</a></li>
  </ul>
</li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-examples-details" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Examples/Details</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-examples-details">
<li><a class="dropdown-item" href="../articles/ordinal.html">Estimation with Ordinal Data</a></li>
    <li><a class="dropdown-item" href="../articles/multilevel.html">Two-level Estimation</a></li>
    <li><a class="dropdown-item" href="../articles/invariance.html">Measurement Invariance</a></li>
    <li><a class="dropdown-item" href="../articles/approx_fi.html">Approximate Fit Indices</a></li>
    <li><a class="dropdown-item" href="../articles/model_comparison.html">Model Comparison</a></li>
    <li><a class="dropdown-item" href="../articles/cross_loadings_strong_priors.html">Cross-loadings with Strong Priors</a></li>
    <li><a class="dropdown-item" href="../articles/mod_indices.html">Modification Indices</a></li>
    <li><a class="dropdown-item" href="../articles/prior_pred_checks.html">Prior Predictive Checks</a></li>
    <li><a class="dropdown-item" href="../articles/convergence_loop.html">Convergence Loop</a></li>
    <li><a class="dropdown-item" href="../articles/probability_direction.html">Probability of Direction</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">News</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/resources.html">Resources</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Functions</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/ecmerkle/blavaan"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://groups.google.com/d/forum/blavaan"><span class="fa fa-users"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Ordinal Models in blavaan</h1>
                        <h4 data-toc-skip class="author">Ed Merkle</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/ecmerkle/blavaan/blob/master/vignettes/ordinal.Rmd" class="external-link"><code>vignettes/ordinal.Rmd</code></a></small>
      <div class="d-none name"><code>ordinal.Rmd</code></div>
    </div>

    
    
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>Structural equation models with ordinal observed variables are
supported starting in <em>blavaan</em> 0.4-1 (<code>target="stan"</code>
only). This document describes the overall approach, which includes
model estimation, threshold parameters, log-likelihood calculation,
posterior predictive p-values, and Jacobians. We assume that you are
somewhat familiar with the layout of SEM; if not, some technical detail
and examples are found in <span class="citation">Merkle and Rosseel
(2018)</span> and, more recently, <span class="citation">Merkle et al.
(2021)</span> (links to these papers are in the references section). We
aim here to provide enough detail to elucidate the new blavaan features,
while being informal enough for you to not get (too) bored.</p>
</div>
<div class="section level3">
<h3 id="estimation">Estimation<a class="anchor" aria-label="anchor" href="#estimation"></a>
</h3>
<p>Ordinal observed variables are handled via data augmentation, in the
style of <span class="citation">Chib and Greenberg (1998)</span>. You
might already know this, but the phrase <em>data augmentation</em> is
imprecise in the context of SEM. This is because there are many possible
things that could be augmented, each of which can make model estimation
easier. We could be augmenting observed data with predictions of missing
data, which is related to multiple imputation methods. We could be
augmenting the observed data with the latent variables, which can
simplify likelihood calculation (leading to what is sometimes called a
<em>conditional</em> likelihood, though <em>conditional</em> also has
many meanings). Or we could be augmenting categorical observed variables
with underlying, latent continuous variables. This last type of
augmentation is what we are doing here. In our testing, we found it to
be faster and more efficient than other approaches that would sample
latent variables alongside other model parameters (the latent variables
are integrated out of our likelihoods here; similar to the description
from <span class="citation">Merkle et al. (2021)</span>).</p>
<p>In our data augmentation implementation, each ordinal observation
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>)
is used to generate a continuous, underlying counterpart (e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^\ast</annotation></semantics></math>).
This
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^\ast</annotation></semantics></math>
must obey the model‚Äôs threshold parameters (commonly denoted
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùõï</mi><annotation encoding="application/x-tex">\mathbf{\tau}</annotation></semantics></math>),
based on the value of the observed data. For example, ignoring
subscripts on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^\ast</annotation></semantics></math>
and assuming an ordinal variable with 4 categories, we would have
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>y</mi><mo>*</mo></msup><mo>&lt;</mo><msub><mi>œÑ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>œÑ</mi><mn>1</mn></msub><mo>&lt;</mo><mspace width="0.222em"></mspace><msup><mi>y</mi><mo>*</mo></msup><mo>&lt;</mo><msub><mi>œÑ</mi><mn>2</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>=</mo><mn>2</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>œÑ</mi><mn>2</mn></msub><mo>&lt;</mo><mspace width="0.222em"></mspace><msup><mi>y</mi><mo>*</mo></msup><mo>&lt;</mo><msub><mi>œÑ</mi><mn>3</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>=</mo><mn>3</mn></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msup><mi>y</mi><mo>*</mo></msup><mo>&gt;</mo><mspace width="0.222em"></mspace><msub><mi>œÑ</mi><mn>3</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> if </mtext><mspace width="0.333em"></mspace></mrow><mi>y</mi><mo>=</mo><mn>4</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
y^* &lt; \tau_1 &amp;\text{ if }y = 1 \\
\tau_1 &lt;\ y^* &lt; \tau_2 &amp;\text{ if }y = 2 \\
\tau_2 &lt;\ y^* &lt; \tau_3 &amp;\text{ if }y = 3 \\
y^* &gt;\ \tau_3 &amp;\text{ if }y = 4
\end{align*}</annotation></semantics></math> where we require
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>œÑ</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>œÑ</mi><mn>2</mn></msub><mo>&lt;</mo><msub><mi>œÑ</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\tau_1 &lt; \tau_2 &lt; \tau_3</annotation></semantics></math>.
We generate such a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
separately for each ordinal observation in the dataset. These all become
additional, bounded parameters in the Stan file.</p>
<p>The Stan User‚Äôs Guide has a helpful example of multivariate probit
regression using a related approach; see <a href="https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html" class="external-link uri">https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html</a>.
The trickiest parts involve enforcing the boundaries of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
variables, and ensuring that the threshold parameters for each ordinal
variable are ordered correctly (while allowing for the possibility that
different ordinal variables have different numbers of thresholds). These
require some Jacobian adjustments that took a good deal of time to code
correctly (some further detail appears in a later section).</p>
<p>Once the above parameters are defined and generated, the remainder of
the model estimation is similar to the simpler situation where all
observed variables are continuous. In terms of the Stan file, most of
the ordinal overhead comes in the transformed parameters block. Once we
get to the model block, most things operate as they would with
continuous data.</p>
</div>
<div class="section level3">
<h3 id="thresholds-priors">Thresholds &amp; Priors<a class="anchor" aria-label="anchor" href="#thresholds-priors"></a>
</h3>
<p>The prior distributions on the threshold
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÑ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>)
parameters are more involved than they may appear. This is because, as
described in the previous section, the threshold parameters for a single
variable must be ordered. So if we say, for example, that all thresholds
have a normal(0,1) prior distribution, we are ignoring the fact that one
threshold‚Äôs value influences the size of other thresholds‚Äô values. As
Michael Betancourt describes on Stan Discourse, such a prior ‚Äúinteracts
with the (ordering) constraint to enforce a sort of uniform repulsion
between the interior points, resulting in very rigid differences.‚Äù</p>
<p>quote from <a href="https://discourse.mc-stan.org/t/prior-choice-for-ordered-inverse-transformed-parameters/16378/3" class="external-link uri">https://discourse.mc-stan.org/t/prior-choice-for-ordered-inverse-transformed-parameters/16378/3</a></p>
<p>To address this issue, we first define an unconstrained, unordered
parameter vector whose length equals the number of thresholds in the
model. Call this vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ùõï</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\mathbf{\tau}^*</annotation></semantics></math>.
We then obtain ordered thresholds by exponentiating the unordered
parameter vector in a specific manner. The manner in which this works is
exactly the same as how Stan defines a parameter of type
<code>ordered</code>. See <a href="https://mc-stan.org/docs/2_28/reference-manual/ordered-vector.html" class="external-link uri">https://mc-stan.org/docs/2_28/reference-manual/ordered-vector.html</a>.
Additionally, a similar idea has been independently developed for signal
detection models by <span class="citation">Paulewicz and Blaut
(2020)</span> (and see their <em>bhsdtr</em> package).</p>
<p>The idea is most easily shown via example. Say that we have an
ordinal variable with 4 categories. Then the three thresholds for this
variable are obtained via:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>œÑ</mi><mn>1</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>œÑ</mi><mn>1</mn><mo>*</mo></msubsup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>œÑ</mi><mn>2</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>œÑ</mi><mn>1</mn><mo>*</mo></msubsup><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>œÑ</mi><mn>2</mn><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>œÑ</mi><mn>3</mn></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msubsup><mi>œÑ</mi><mn>1</mn><mo>*</mo></msubsup><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>œÑ</mi><mn>2</mn><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>œÑ</mi><mn>3</mn><mo>*</mo></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\tau_1 &amp;= \tau^*_1 \\
\tau_2 &amp;= \tau^*_1 + \exp(\tau^*_2) \\
\tau_3 &amp;= \tau^*_1 + \exp(\tau^*_2) + \exp(\tau^*_3).
\end{align*}</annotation></semantics></math> We then place normal prior
distributions on the unordered
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>œÑ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\tau^*</annotation></semantics></math>
parameters, as opposed to placing priors on the ordered
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÑ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
parameters. These normal priors imply that the lowest threshold
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>œÑ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\tau_1</annotation></semantics></math>
above) has a normal prior, while differences between successive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÑ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>‚Äôs
have log-normal priors. In blavaan, these priors can be specified in the
usual two ways. First, we could add the <code>dp</code> argument to a
model estimation command as follows.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dp</span> <span class="op">=</span> <span class="fu"><a href="../reference/dpriors.html">dpriors</a></span><span class="op">(</span>tau <span class="op">=</span> <span class="st">"normal(0, .5)"</span><span class="op">)</span></span></code></pre></div>
<p>which would assign this prior to all the unordered
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>œÑ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\tau^*</annotation></semantics></math>
parameters in the model. Second, we could specify priors for specific
threshold parameters in the model specification syntax. For example, say
that we have a 4-category observed variable called <code>x1</code>. Then
unique priors for each the three thresholds could be specified in the
model syntax via</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x1</span> <span class="op">|</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(-1, 1)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t1</span> <span class="op">+</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(0, .5)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t2</span> <span class="op">+</span> <span class="fu">prior</span><span class="op">(</span><span class="st">"normal(0, 1)"</span><span class="op">)</span> <span class="op">*</span> <span class="va">t3</span></span></code></pre></div>
<p>It is not clear at this time that priors on the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>œÑ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\tau^*</annotation></semantics></math>
parameters are the best option. In a 2019 paper, Michael Betancourt
describes a Dirichlet prior that regularizes the thresholds of an
ordinal regression model. Such a strategy would seem to work for SEM,
and it could be especially useful for datasets where some categories of
the ordinal variable are sparse. These issues warrant further study.</p>
<p><a href="https://betanalpha.github.io/assets/case_studies/ordinal_regression.html" class="external-link uri">https://betanalpha.github.io/assets/case_studies/ordinal_regression.html</a></p>
</div>
<div class="section level3">
<h3 id="likelihood-computations">Likelihood Computations<a class="anchor" aria-label="anchor" href="#likelihood-computations"></a>
</h3>
<p>Once we get to continuous data in the model block, it seems
reasonable to expect simple likelihood computations. But it depends on
what likelihood you want to compute. The likelihood used for sampling in
Stan is a simple multivariate normal of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
observations, combined with any continuous observed variables in the
model. This is indeed simple to compute. But it is not the likelihood
you want to use for model comparison. For one thing, all the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
parameters associated with ordinal data are involved in this likelihood,
so quantities like the effective number of parameters become very
inflated. The number of parameters involved in this likelihood also
increases with sample size, which is generally bad in the land of model
comparison metrics. See <span class="citation">Merkle, Furr, and
Rabe-Hesketh (2019)</span> for more detail here.</p>
<p>All this means that, for quantities like WAIC and PSIS-LOO, we must
compute a second model likelihood that involves the observed, ordinal
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>
variables and that integrates over the latent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
variables. This is a difficult problem that amounts to evaluating the
CDF of a sometimes-high-dimensional, multivariate normal distribution
<span class="citation">(see Chib and Greenberg 1998, Equation
11)</span>. There are multiple possibilities for approximating this CDF.
We currently rely on the <code>sadmvn()</code> function from the
<em>mnormt</em> package <span class="citation">(Azzalini and Genz
2020)</span>, which uses a subregion adaptive integration method by
<span class="citation">Genz (1992)</span> that is fast and accurate
(when there are about 15 or fewer ordinal variables in the model). A
second possibility involves Monte Carlo simulation, which is implemented
in the <em>tmvnsim</em> package <span class="citation">(Bhattacjarjee
2016)</span>. For each case, we generate many random samples from the
appropriate truncated multivariate normal and average over the resulting
importance sampling weights. The procedure is computationally intensive
and also time intensive, so we have to balance the number of random
samples drawn with the amount of time that it takes. If users wish to
use <code>tmvnsim()</code>, they must declare the number of importance
samples to draw. This is accomplished by setting <code>llnsamp</code>
within the <code>mcmcextra$data</code> argument. For example, to draw
100 samples for the approximation, a call to <code><a href="../reference/bsem.html">bsem()</a></code> or
similar functions would include the argument</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mcmcextra</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>llnsamp <span class="op">=</span> <span class="fl">100</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Beyond these two methods, it would also be possible to use quadrature
over the latent variables. Many people would consider quadrature to be
the gold standard here, and quadrature would reduce the dimension of
integration for many models (because there are usually fewer latent
variables than observed variables). But the quadrature would have to be
specific to SEM, and fast, efficient, open implementations of such a
method do not appear to currently exist (some implementations are hidden
in <em>blavaan</em>, but they are pure R implementations that are fairly
slow). On the other hand, approximation of the multivariate normal CDF
is a general problem that has multiple fast, efficient, open
implementations, so long as there are not too many ordinal variables in
your model.</p>
<p>There also exists a relatively new method by <span class="citation">Z. I. Botev (2017)</span> for evaluating the CDF of the
multivariate normal, with an implementation of the method appearing in
the package <em>TruncatedNormal</em> <span class="citation">(Z. Botev
and Belzile 2021)</span>. This method is especially useful for
evaluating high-dimensional normal distributions (in our case, with more
than about 15 ordinal variables), and it may be incorporated in future
versions of <em>blavaan</em>.</p>
<!-- TODO Bayes factor, use chib's identity? -->
</div>
<div class="section level3">
<h3 id="comparison-to-lavaan">Comparison to <em>lavaan</em><a class="anchor" aria-label="anchor" href="#comparison-to-lavaan"></a>
</h3>
<p>Ordinal SEM is associated with two types of model parameterizations:
<em>delta</em> and <em>theta</em>. These refer to different scale
parameterizations of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
variables: <em>delta</em> refers to the total standard deviation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>
(including variability due to latent variables), and <em>theta</em>
refers to the residual standard deviation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>y</mi><mo>*</mo></msup><annotation encoding="application/x-tex">y^*</annotation></semantics></math>.</p>
<p>In <em>blavaan</em>, only the theta parameterization is implemented.
So, if you want to compare <em>lavaan</em> results to <em>blavaan</em>
results, you need to use the argument
<code>parameterization = "theta"</code> when you estimate the
<em>lavaan</em> model.</p>
<p>Also, the default <em>lavaan</em> estimator for ordinal models is a
multiple-step procedure that involves a weighted least squares
discrepancy function. The resulting parameter estimates are sometimes
far from the posterior means reported by <em>blavaan</em>. The
<em>blavaan</em> estimates are usually closer to
<code>estimator="PML"</code> in <em>lavaan</em>.</p>
</div>
<div class="section level3">
<h3 id="posterior-predictive-p-values">Posterior Predictive p-values<a class="anchor" aria-label="anchor" href="#posterior-predictive-p-values"></a>
</h3>
<p>Posterior predictive p-value (ppp) computations receive a speed boost
in the 0.4 series. These computations now occur in Stan, whereas they
previously occurred in R after model estimation. As discussed by <span class="citation">Asparouhov and Muth√©n (2021)</span>, the ppp
computations needed for models with missing data can be excessively
slow, requiring us to run an EM algorithm for each posterior sample in
order to find the ‚ÄúH1‚Äù (‚Äúsaturated‚Äù) model covariance matrix. The
solution by <span class="citation">Asparouhov and Muth√©n (2021)</span>
involves the realization that we do not need to use a fully-optimized H1
covariance matrix in order to compute the ppp. In <em>blavaan</em>, we
consequently run an EM algorithm for a fixed number of iterations in
order to compute an H1 covariance matrix that is ‚Äúgood enough‚Äù for the
ppp. The default number of iterations it set to 20, and users can change
the default by supplying an <code>emiter</code> value via the
<code>mcmcextra</code> argument. For example,</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mcmcextra</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>emiter <span class="op">=</span> <span class="fl">50</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="jacobians">Jacobians<a class="anchor" aria-label="anchor" href="#jacobians"></a>
</h3>
<p><em>(This section is likely only relevant to you if you are
editing/writing Stan models.)</em> The Stan model underlying
<em>blavaan</em> currently requires Jacobian adjustments in two places.
This section briefly reviews the ideas underneath the adjustments, which
my future self may wish to remember.</p>
<p>We need a Jacobian adjustment when we place a prior on something that
does not appear in the Stan <code>parameters</code> block. The Jacobian
tells us about the implied priors of the things in the
<code>parameters</code> block, based on the priors that appear in the
<code>model</code> block.</p>
<p>The Jacobian comes from the statistics literature on ‚Äúchange of
variables‚Äù: we are applying a function to some random variables, and
finding the distribution of the function based on the original
distribution of the random variables. When it comes to Stan models, this
means we are starting with the priors from the <code>model</code> block
and finding the implied priors for the <code>parameters</code> block.
This confused me for a long time because, in the Stan file, the
functions naturally go in the opposite direction: starting with the
<code>parameters</code> block, and moving to the <code>model</code>
block.</p>
<p>The fact that our functions go from <code>model</code> to
<code>parameters</code> is convenient, though, because Jacobian
adjustments require the inverse functions. And the inverse functions
move us from <code>parameters</code> to <code>model</code>, so they
already exist in the Stan model. We just need to find the appropriate
derivatives of these functions, which lead to the Jacobian.</p>
<p>As an example, consider the fact that <em>blavaan</em> allows users
to choose whether priors go on standard deviation, variance, or
precision parameters. The standard deviations appear in the
<code>parameters</code> block regardless of what the user chooses (the
Stan model is precompiled at the time of package installation). Say that
the user wants priors on precisions. We transform the standard
deviations to precisions in the <code>model</code> block, then put the
prior on the precision. In addition to this prior, we need the Jacobian
of the function that starts with a standard deviation (call it
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÉ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>)
and transforms to precision
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>œÉ</mi><mrow><mo>‚àí</mo><mn>2</mn></mrow></msup><annotation encoding="application/x-tex">\sigma^{-2}</annotation></semantics></math>).
The derivative of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>œÉ</mi><mrow><mo>‚àí</mo><mn>2</mn></mrow></msup><annotation encoding="application/x-tex">\sigma^{-2}</annotation></semantics></math>
with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>œÉ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>‚àí</mo><mn>2</mn><msup><mi>œÉ</mi><mrow><mo>‚àí</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2 \sigma^{-3}</annotation></semantics></math>.
And because this is a simple function mapping a single parameter to a
different value, the Jacobian is the absolute value of this derivative,
which is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>œÉ</mi><mrow><mo>‚àí</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2 \sigma^{-3}</annotation></semantics></math>.
In the Stan file, we would then add the log of this Jacobian to
<code>target</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>target <span class="op">+=</span> log<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">-</span> <span class="dv">3</span><span class="op">*</span>log<span class="op">(</span>sigma<span class="op">)</span></span></code></pre></div>
<p>Further examples and discussion can be found in:</p>
<p><a href="https://mc-stan.org/users/documentation/case-studies/mle-params.html" class="external-link uri">https://mc-stan.org/users/documentation/case-studies/mle-params.html</a></p>
</div>
<div class="section level3">
<h3 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a>
</h3>
<p>The <em>blavaan</em> 0.4 series offers enhanced functionality in a
variety of areas. The computational decisions that we have made reflect
a balance between estimation precision and estimation speed. It will be
the case that the software defaults behave poorly in some situations.
For example, the default prior distributions can be problematic in
certain situations, the likelihood approximations for ordinal models may
not be as precise as desired, and the new ppp computations may behave
differently than previous computations. We encourage users to carry out
sensitivity analyses, and also to report bugs!</p>
</div>
<div class="section level3 unnumbered">
<h3 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h3>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-aspmut21" class="csl-entry">
Asparouhov, Tihomir, and Bengt Muth√©n. 2021. <span>‚ÄúAdvances in
<span>Bayesian</span> Model Fit Evaluation for Structural Equation
Models.‚Äù</span> <em>Structural Equation Modeling: A Multidisciplinary
Journal</em> 28 (1): 1‚Äì14. <a href="https://doi.org/10.1080/10705511.2020.1764360" class="external-link">https://doi.org/10.1080/10705511.2020.1764360</a>.
</div>
<div id="ref-azzgen20" class="csl-entry">
Azzalini, A., and A. Genz. 2020. <em>The <span>R</span> Package
<code>mnormt</code>: The Multivariate Normal and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
Distributions (Version 2.0.2)</em>. <a href="http://azzalini.stat.unipd.it/SW/Pkg-mnormt/" class="external-link">http://azzalini.stat.unipd.it/SW/Pkg-mnormt/</a>.
</div>
<div id="ref-tmvnsim" class="csl-entry">
Bhattacjarjee, Samsiddhi. 2016. <em><span class="nocase">tmvnsim:
Truncated</span> Multivariate Normal Simulation</em>. <a href="https://CRAN.R-project.org/package=tmvnsim" class="external-link">https://CRAN.R-project.org/package=tmvnsim</a>.
</div>
<div id="ref-bot17" class="csl-entry">
Botev, Z. I. 2017. <span>‚ÄúThe Normal Law Under Linear Restrictions:
Simulation and Estimation via Minimax Tilting.‚Äù</span> <em>Journal of
the Royal Statistical Society: Series B</em> 79 (1): 125‚Äì48.
https://doi.org/<a href="https://doi.org/10.1111/rssb.12162" class="external-link">https://doi.org/10.1111/rssb.12162</a>.
</div>
<div id="ref-tn21" class="csl-entry">
Botev, Zdravko, and Leo Belzile. 2021. <em>TruncatedNormal: Truncated
Multivariate Normal and Student Distributions</em>. <a href="https://CRAN.R-project.org/package=TruncatedNormal" class="external-link">https://CRAN.R-project.org/package=TruncatedNormal</a>.
</div>
<div id="ref-chigre98" class="csl-entry">
Chib, S., and E. Greenberg. 1998. <span>‚ÄúAnalysis of Multivariate Probit
Models.‚Äù</span> <em>Biometrika</em> 85: 347‚Äì61.
</div>
<div id="ref-gen92" class="csl-entry">
Genz, A. 1992. <span>‚ÄúNumerical Computation of the Multivariate Normal
Probabilities.‚Äù</span> <em>Journal of Computational and Graphical
Statistics</em> 1: 141‚Äì50.
</div>
<div id="ref-merfit21" class="csl-entry">
Merkle, E. C., E. Fitzsimmons, J. Uanhoro, and B. Goodrich. 2021.
<span>‚ÄúEfficient <span>Bayesian</span> Structural Equation Modeling in
<span>Stan</span>.‚Äù</span> <em>Journal of Statistical Software</em> 100
(6): 1‚Äì22. <a href="https://www.jstatsoft.org/article/view/v100i06" class="external-link">https://www.jstatsoft.org/article/view/v100i06</a>.
</div>
<div id="ref-merfur19" class="csl-entry">
Merkle, E. C., D. Furr, and S. Rabe-Hesketh. 2019.
<span>‚Äú<span>Bayesian</span> Comparison of Latent Variable Models:
<span>Conditional</span> Versus Marginal Likelihoods.‚Äù</span>
<em>Psychometrika</em> 84: 802‚Äì29. <a href="https://arxiv.org/abs/1802.04452" class="external-link">https://arxiv.org/abs/1802.04452</a>.
</div>
<div id="ref-merros18" class="csl-entry">
Merkle, E. C., and Y. Rosseel. 2018. <span>‚Äú<span class="nocase">blavaan</span>: <span>Bayesian</span> Structural Equation
Models via Parameter Expansion.‚Äù</span> <em>Journal of Statistical
Software</em> 85 (4): 1‚Äì30. <a href="https://www.jstatsoft.org/article/view/v085i04" class="external-link">https://www.jstatsoft.org/article/view/v085i04</a>.
</div>
<div id="ref-paubla20" class="csl-entry">
Paulewicz, B., and A. Blaut. 2020. <span>‚ÄúThe <span class="nocase">bhsdtr</span> Package: <span>A</span> General-Purpose
Method of <span>Bayesian</span> Inference for Signal Detection Theory
Models.‚Äù</span> <em>Behavior Research Methods</em> 52: 2122‚Äì41.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Edgar Merkle, Yves Rosseel, Ben Goodrich.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
